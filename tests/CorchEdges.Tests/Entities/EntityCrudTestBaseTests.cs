using CorchEdges.Data;
using CorchEdges.Data.Entities;
using CorchEdges.Tests.Infrastructure;
using Microsoft.EntityFrameworkCore;

namespace CorchEdges.Tests.Entities;

public abstract class EntityCrudTestBase<TEntity> : MemoryDatabaseTestBase 
    where TEntity : class
{
    protected abstract TEntity CreateValidEntity(ProcessedFile processedFile);
    protected abstract void ModifyEntity(TEntity entity);
    protected abstract DbSet<TEntity> GetDbSet(EdgesDbContext context);
    protected virtual bool HasAutoGeneratedId => true;

    [Fact]
    [Trait("Operation", "Create")]
    public async Task Create_ValidEntity_SavesSuccessfully()
    {
        // Create fresh DbContext and transaction for this test
        using var dbContext = CreateInMemoryDbContext();
        // using var transaction = await Connection.BeginTransactionAsync();
        // await dbContext.Database.UseTransactionAsync(transaction);
        var processedFile = new ProcessedFile();
        dbContext.ProcessedFiles.Add(processedFile);
        await dbContext.SaveChangesAsync(TestContext.Current.CancellationToken);

        // Arrange
        var entity = CreateValidEntity(processedFile);

        // Act
        GetDbSet(dbContext).Add(entity);
        var result = await dbContext.SaveChangesAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(1, result);
        
        // Verify entity was saved
        var savedEntity = await GetDbSet(dbContext).FirstOrDefaultAsync(TestContext.Current.CancellationToken);
        Assert.NotNull(savedEntity);
        
        // Transaction will rollback when disposed
    }

    [Fact]
    [Trait("Operation", "Read")]
    public async Task Read_ExistingEntity_ReturnsCorrectly()
    {
        using var dbContext = CreateInMemoryDbContext();
        // using var transaction = await Connection.BeginTransactionAsync();
        // await dbContext.Database.UseTransactionAsync(transaction);
        var processedFile = new ProcessedFile();
        dbContext.ProcessedFiles.Add(processedFile);
        await dbContext.SaveChangesAsync(TestContext.Current.CancellationToken);

        // Arrange
        var entity = CreateValidEntity(processedFile);
        GetDbSet(dbContext).Add(entity);
        await dbContext.SaveChangesAsync(TestContext.Current.CancellationToken);

        // Act
        var retrievedEntity = await GetDbSet(dbContext).FirstOrDefaultAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.NotNull(retrievedEntity);
        AssertEntitiesEqual(entity, retrievedEntity);
    }

    [Fact]
    [Trait("Operation", "Update")]
    public async Task Update_ExistingEntity_UpdatesSuccessfully()
    {
        using var dbContext = CreateInMemoryDbContext();
        // using var transaction = await Connection.BeginTransactionAsync();
        // await dbContext.Database.UseTransactionAsync(transaction);
        var processedFile = new ProcessedFile();
        dbContext.ProcessedFiles.Add(processedFile);
        await dbContext.SaveChangesAsync(TestContext.Current.CancellationToken);

        // Arrange
        var entity = CreateValidEntity(processedFile);
        GetDbSet(dbContext).Add(entity);
        await dbContext.SaveChangesAsync(TestContext.Current.CancellationToken);

        // Act
        ModifyEntity(entity);
        var result = await dbContext.SaveChangesAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(1, result);
        
        // Verify changes were persisted
        var updatedEntity = await GetDbSet(dbContext).FirstOrDefaultAsync(TestContext.Current.CancellationToken);
        Assert.NotNull(updatedEntity);
        AssertEntitiesEqual(entity, updatedEntity);
    }

    [Fact]
    [Trait("Operation", "Delete")]
    public async Task Delete_ExistingEntity_RemovesSuccessfully()
    {
        using var dbContext = CreateInMemoryDbContext();
        // using var transaction = await Connection.BeginTransactionAsync();
        // await dbContext.Database.UseTransactionAsync(transaction);
        var processedFile = new ProcessedFile();
        dbContext.ProcessedFiles.Add(processedFile);
        await dbContext.SaveChangesAsync(TestContext.Current.CancellationToken);
   
        // Arrange
        var entity = CreateValidEntity(processedFile);
        GetDbSet(dbContext).Add(entity);
        await dbContext.SaveChangesAsync(TestContext.Current.CancellationToken);

        // Act
        GetDbSet(dbContext).Remove(entity);
        var result = await dbContext.SaveChangesAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(1, result);
        
        // Verify entity was deleted
        var deletedEntity = await GetDbSet(dbContext).FirstOrDefaultAsync(TestContext.Current.CancellationToken);
        Assert.Null(deletedEntity);
    }

    [Fact]
    [Trait("Operation", "BulkCreate")]
    public async Task Create_MultipleEntities_SavesAllSuccessfully()
    {
        using var dbContext = CreateInMemoryDbContext();
        // using var transaction = await Connection.BeginTransactionAsync();
        // await dbContext.Database.UseTransactionAsync(transaction);
        
        // Arrange
        var processedFile = new ProcessedFile();
        dbContext.ProcessedFiles.Add(processedFile);
        await dbContext.SaveChangesAsync(TestContext.Current.CancellationToken);

        var entities = new[]
        {
            CreateValidEntity(processedFile),
            CreateValidEntity(processedFile),
            CreateValidEntity(processedFile)
        };

        // Act
        GetDbSet(dbContext).AddRange(entities);
        var result = await dbContext.SaveChangesAsync(TestContext.Current.CancellationToken);

        // Assert
        Assert.Equal(3, result);
        
        // Verify all entities were saved
        var count = await GetDbSet(dbContext).CountAsync(TestContext.Current.CancellationToken);
        Assert.Equal(3, count);
    }
    

    protected virtual void AssertEntitiesEqual(TEntity expected, TEntity actual)
    {
        // Override in derived classes for specific equality checks
        Assert.NotNull(actual);
    }
}